#include <iostream>

//함수 매개변수에 const를 사용하는 경우
void Func(const int* pInt)
{
    //매개변수 포인터에 const를 붙이면, 값이 수정될 일이 없다는 것을 암시 
    //포인터를 상수화 시켰기 때문에 접근은 가능
    int i = *pInt;

    //포인터의 값을 수정하는 것은 불가능
    //*pInt = 300;

    //하지만 const가 붙어도, 새로운 포인터를 통해 값 변경 가능 -> 비정상 접근
    //대부분의 경우 매개변수가 const이면, 값을 유지한다는 의미로 알면 됨
}

//void : 리턴값이 존재하지 않는 반환 타입, 리턴을 써도되긴함



int main()
{
    //포인터 변수 = 주소를 저장하는 변수
    //해당 포인터에게 전달된 주소를 해석하는 단위
    int i = 100;
    float f = 3.f;

    int* pInt = (int*)&f;

    //포인터 변수의 크기는 운영체제 플랫폼에 따라 크기가 바뀜
    //32비트 운영체제 -> 4바이트
    //64비트 운영체제 -> 8바이트 -> 타겟 운영체제에 비례함

    int iSize = sizeof(int*); // 8 반환
    
    //포인터 연산은 정수연산x
    pInt += 1;
    //pInt는 주소가 담겨있다. 여기서 1을 더하면
    //순수하게 주소값에 1이 더해지는 게 아니라, 가리키는 타입의
    //크기만큼 더해진다 -> 다음 int데이터 주소를 가리킴

    //포인터와 배열
    int iArr[10] = {};
    //10묶음의 int가 한번에 선언됨 + 배열은 데이터가 연속적으로 자리함
    //이 특징을 포인터처럼 사용 가능.
    //배열의 이름 = 배열의 시작주소(첫번째 원소 주소) -> 포인터

    //시작 주소로부터 1칸 뒤에 있는 데이터에 접근
    //iArr은 int타입이기 때문에, int 단위로 다음 칸(4바이트)
    *(iArr + 1) = 10; // iArr[1] = 10;과 같은 동작

    //const 키워드
    const int cint = 100;
    //cint가 const가 붙었기 때문에 값이 바뀔수 없게 c가 막아줌
    //그러나 주소로 접근하여 바꾸면, 값을 바꿀 수 있음
    //하지만 레지스터 최적화로 인해 값이 안 바뀐것 처럼 표현
    //volatile(비휘발성) 키워드를 붙이면 수정가능 -> 메모리에서 값을 가져옴

    10; //10은 그 자체로 상수이며, 10이라는 것을 다른 값으로 바꿀 수없음
    //const는 변수를 상수화 시키는 키워드임.(r-value)
    //바뀔 수 있는 값, 변수들은 모두 l-value
    int a = 0;
    pInt = &a;

    //포인터가 const와 묶이면, 두가지 경우가 생김
    //포인터가 가리키는 곳을 변경 할 것인지
    //자기 자체가 const가 될 것인지(자신의 원본 변경x)

    //const 포인터 = 포인터를 상수화시킴
    //가리키는 곳을 바꿀 수는 있지만, 원본은 변경불가
    const int* pConstInt = &a;

    //cosnt 포인터를 접근하는 것은 문제가 없지만, 수정은 문제
    //*pConstInt = 100;
    //포인터가 상수화되었기 때문에, 원본을 건드릴 수 없음

    //가리키는 곳은 변경이 가능
    int b = 0;
    pConstInt = &b;

    //포인터 const
    //원본을 변경 가능하지만, 가리키는 곳은 변경 불가능
    int* const pIntConst = &a;

    *pIntConst = 100;
    //변수 자체가 상수화 되었기 때문에 변수가 a와 동일시 됨

    //이 경우에 가리키는 곳과 값을 모두 바꿀 수 없음(read only)
    const int* const pConstIntConst = nullptr;

    int const* p = &a;

    //함수 매개변수로 포인터 사용
    b = 200;
    Func(&b);
    //b의 주소가 아닌 b의 값을 매개변수로 하는 경우에는,
    //b에 대한 똑같은 값을 가지는 변수를 다시 만든다.
    //이 때 매개변수 타입이 무겁거나, 싱글톤 객체라면 문제가됨


    //void 포인터, 주소를 저장할 수 있는 변수임
    void* pVoid = nullptr;
    //하지만 void타입이기 때문에, 원본 변수에 대한 자료형을 정하지않음
    //어떤 변수든 받을 수 있음(auto)

    //다른 타입을 가진 포인터 = 그 주소를 접근 할 단위를 표시함
    float* pFloat = nullptr; //float면, 포인터 크기는 4바이트.

    pVoid = &b; //int 변수의 주소를 담은 void 포인터
    //void 포인터는 주소값을 받았을 때, 값이 무엇인지 신경쓰지 않음
    //값이 저장되는 것이 아니기 때문에, 역참조 불가능 -> 주소 임시저장 역할
    //주소연산 또한 불가능(데이터 크기가 정의되지 않았기 때문에)

    //포인터에서 가장 중요한 개념
    //원본에서 일어나는 일은 포인터와는 무관하다.
    //포인터는 반드시 데이터 타입을 매칭시켜서 사용해야 한다.
    //값이 변경될 조짐이 보이거나 데이터를 보존하고 싶다면 const를 사용해라

    return 0;
}